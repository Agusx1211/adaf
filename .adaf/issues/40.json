{
  "id": 40,
  "title": "Daemon drops TUI client on attach due to non-blocking enqueue backpressure",
  "description": "## Summary\n\nWhen attaching to a busy session (e.g. an opus-managed loop with multiple spawns), the TUI client is frequently disconnected with \"connection to session daemon lost\". This is a regression from the fix for issue #5: the deadlock was eliminated by switching to non-blocking enqueue + per-client writer goroutines, but now slow clients are silently dropped instead.\n\n## Root cause\n\nThe enqueue() function in internal/session/daemon.go uses a non-blocking channel send. When broadcastPrepared() gets false from enqueue(), it immediately calls removeClient(), closing the connection. The client-side scanner sees EOF without a MsgDone and emits \"connection to session daemon lost\" (client.go:184).\n\n## Two backpressure chains cause the buffer to fill\n\n**Chain 1 - TUI rendering bottleneck:**\n1. TUI bubbletea Update() loop processes events one-at-a-time\n2. eventCh (buffer 256) fills up\n3. StreamEvents blocks on eventCh send, stops reading the scanner\n4. OS socket buffer fills, writeImmediate hits 5-second deadline, removeClient called\n\n**Chain 2 - Direct enqueue overflow:**\n1. Agent loop produces events faster than the writer goroutine can drain sendCh (buffer 512)\n2. Next enqueue() call fails, logs \"dropping slow client due to outbound backpressure\", removeClient called\n\n## Race condition in handleClient\n\nThere is a race window between client registration and writer startup. The client is added to b.clients (can receive broadcasts) before startWriter() is called. Between registration and startWriter(), broadcasts enqueue into sendCh with nobody draining it. If 512+ events arrive during snapshot encoding/sending, the client is dropped before it finishes connecting.\n\n## Missing: no keepalive/heartbeat\n\nThere is no ping/pong or heartbeat mechanism. During idle periods, neither side can detect a stale connection.\n\n## Observed impact\n\nIn the opus-manager loop run (commit 032d8331), attaching to a running session with 5 agents (multiple spawns actively producing events) consistently fails with \"connection to session daemon lost\" shortly after attach.\n\n## Suggested resolution\n\nThis issue will be addressed as part of p10-web-foundation by replacing the raw Unix socket protocol with an HTTP/WebSocket server on the same Unix socket path. WebSocket libraries (nhooyr.io/websocket) provide proper write buffering, ping/pong keepalive, and graceful close frames, eliminating the hand-rolled backpressure policy. See updated p10 plan phase for details.\n\n## Files involved\n\n- internal/session/daemon.go: enqueue(), broadcastPrepared(), handleClient(), removeClient()\n- internal/session/client.go: StreamEvents() emits the error at line 184\n- internal/cli/attach_cmd.go: runAttach() creates eventCh with buffer 256",
  "status": "open",
  "priority": "high",
  "labels": [
    "bug",
    "daemon",
    "tui",
    "session"
  ],
  "created": "2026-02-14T09:47:48.944199858Z",
  "updated": "2026-02-14T09:47:48.944199858Z"
}